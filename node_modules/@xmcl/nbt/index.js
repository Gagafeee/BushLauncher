/**
 * The nbt module provides nbt {@link serialize} and {@link deserialize} functions.
 *
 * @packageDocumentation
 */
import ByteBuffer from "bytebuffer";
import fileType from "file-type";
import { readUTF8, writeUTF8 } from "./utils";
import { ungzip, inflate, gunzipSync, gzip, gzipSync, inflateSync, deflateSync, deflate } from "./zlib";
export const NBTPrototype = Symbol("NBTPrototype");
export const NBTConstructor = Symbol("NBTConstructor");
/**
 * Annotate the type of a field
 */
export function TagType(type) {
    return (targetClass, key) => {
        let nbtPrototype = getPrototypeOf(targetClass.constructor);
        nbtPrototype[key] = type;
    };
}
/**
 * Construct the object from schema or constructor.
 *
 * - If pass-in value type is a schema object, it create a prototype with constructor constructing the object with this schema as NBTPrototype.
 * - If pass-in value is a constructor, it will try to take the NBTPrototype on the constructor to create object.
 */
function constructObject(valueType) {
    if (!valueType) {
        return {};
    }
    const prot = typeof valueType === "object" ? createPrototypeFrom(valueType) : getPrototypeOf(valueType);
    return prot[NBTConstructor]();
}
function createPrototypeFrom(schema, constructor) {
    const proto = {
        ...schema,
    };
    Object.defineProperty(proto, NBTConstructor, {
        value: () => {
            let object;
            if (constructor) {
                try {
                    object = new constructor();
                }
                catch (_a) {
                    object = {};
                    Object.setPrototypeOf(object, constructor.prototype);
                }
            }
            else {
                object = {};
            }
            Object.defineProperty(object, NBTPrototype, { value: proto });
            return object;
        },
    });
    return proto;
}
/**
 * Get NBT schema for this object or a class.
 *
 * If the param is a object, any modifications on this prototype will only affact this object.
 *
 * If the param is a class, any modifications on this prototype will affact all object under this class
 *
 * @param object The object or class
 */
export function getPrototypeOf(object) {
    const targetObject = typeof object === "function" ? object.prototype : object;
    let nbtPrototype;
    if (targetObject.hasOwnProperty(NBTPrototype)) {
        nbtPrototype = targetObject[NBTPrototype];
    }
    else {
        nbtPrototype = createPrototypeFrom({}, typeof object === "function" ? object : undefined);
    }
    // link prototype to parent's nbt prototype
    // we need to do this every time since the prototype chain might change
    const parentClass = Object.getPrototypeOf(targetObject);
    if (parentClass && parentClass !== Object.getPrototypeOf({})) {
        const parentNBTPrototype = getPrototypeOf(parentClass);
        const existedParentNBTPrototype = Object.getPrototypeOf(nbtPrototype);
        if (existedParentNBTPrototype !== parentNBTPrototype) {
            Object.setPrototypeOf(nbtPrototype, parentNBTPrototype);
        }
    }
    return new Proxy(nbtPrototype, {
        set(target, key, value) {
            if (!object.hasOwnProperty(NBTPrototype)) {
                setPrototypeOf(object, target);
            }
            if (typeof key === "string") {
                if (typeof value === "number" && !isTagType(value)) {
                    return false;
                }
                target[key] = value;
                return true;
            }
            return false;
        },
    });
}
/**
 * Set and change the NBT prototype of this object or class
 * @param object A object or a class function
 * @param nbtPrototype The nbt prototype
 */
export function setPrototypeOf(object, nbtPrototype) {
    const target = typeof object === "function" ? object.prototype : object;
    Object.defineProperty(target, NBTPrototype, { value: nbtPrototype });
}
function isTagType(n) {
    return n >= 0 && n <= 12;
}
(function (TagType) {
    TagType.End = 0;
    TagType.Byte = 1;
    TagType.Short = 2;
    TagType.Int = 3;
    TagType.Long = 4;
    TagType.Float = 5;
    TagType.Double = 6;
    TagType.ByteArray = 7;
    TagType.String = 8;
    TagType.List = 9;
    TagType.Compound = 10;
    TagType.IntArray = 11;
    TagType.LongArray = 12;
    function getName(tagType) {
        return [
            "End",
            "Byte",
            "Short",
            "Int",
            "Long",
            "Float",
            "Double",
            "ByteArray",
            "String",
            "List",
            "Compound",
            "IntArray",
            "LongArray",
        ][tagType];
    }
    TagType.getName = getName;
})(TagType || (TagType = {}));
const IO = [
    { read: (buf) => undefined, write(buf, v) { } },
    { read: (buf) => buf.readByte(), write(buf, v = 0) { buf.writeByte(v); } },
    { read: (buf) => buf.readShort(), write(buf, v = 0) { buf.writeShort(v); } },
    { read: (buf) => buf.readInt(), write(buf, v = 0) { buf.writeInt(v); } },
    { read: (buf) => buf.readInt64(), write(buf, v = 0) { buf.writeInt64(v); } },
    { read: (buf) => buf.readFloat(), write(buf, v = 0) { buf.writeFloat(v); } },
    { read: (buf) => buf.readDouble(), write(buf, v = 0) { buf.writeDouble(v); } },
    {
        read(buf) {
            const arr = new Array(buf.readInt());
            for (let i = 0; i < arr.length; i++) {
                arr[i] = buf.readByte();
            }
            return arr;
        },
        write(buf, arr = []) {
            buf.writeInt(arr.length);
            for (let i = 0; i < arr.length; i++) {
                buf.writeByte(arr[i]);
            }
        },
    },
    { read: (buf) => readUTF8(buf), write: (buf, v = "") => writeUTF8(buf, v) },
    {
        read(buf, context) {
            const listType = buf.readByte();
            assertTag(listType);
            const len = buf.readInt();
            const list = new Array(len);
            if (context.schema) {
                assertListSchema(context.schema);
            }
            if (!!context.schema && typeof context.schema === "number" && listType !== context.schema) {
                // ignore the value if we know the type mismatched
                return list;
            }
            const childContext = context.fork(context.schema ? context.schema[0] : listType);
            const shouldInspectChildType = !childContext.schema;
            for (let i = 0; i < len; i++) {
                // console.log(`[read] ${shouldInspectChildType ? 'inspecting' : ''} -> [${i}]: ${JSON.stringify(nextContext.valueType)} ${TagType.getName(listType)}`);
                list[i] = IO[listType].read(buf, childContext);
                // console.log(`[read] ${shouldInspectChildType ? 'inspecting' : ''} <- [${i}]: ${JSON.stringify(nextContext.valueType)} ${TagType.getName(listType)} ${JSON.stringify(list[i])}`);
            }
            if (shouldInspectChildType) {
                context.inspect = childContext.inspect || [childContext.tagType];
            }
            return list;
        },
        write(buf, value = [], context) {
            assertListSchema(context.schema);
            const valueType = context.schema[0];
            const childContext = context.fork(valueType);
            const tagType = childContext.tagType;
            const writer = IO[tagType];
            assertTag(tagType);
            if ((tagType === TagType.Compound || tagType === TagType.List) && !childContext.schema) {
                // skip for undefined property
                return;
            }
            try {
                buf.writeByte(tagType);
                buf.writeInt(value.length);
                for (const v of value) {
                    writer.write(buf, v, childContext);
                }
            }
            catch (e) {
                if (e instanceof TypeError) {
                    throw new TypeError(`Require ${TagType.getName(tagType)} but found ${typeof value}`);
                }
            }
        },
    },
    {
        read(buf, context) {
            assertCompoundSchema(context.schema);
            const object = constructObject(context.schema); // create from constructor
            const nbtPrototype = getPrototypeOf(object);
            const knowingType = !!context.schema;
            for (let tag = 0; (tag = buf.readByte()) !== TagType.End;) {
                const reader = IO[tag];
                const key = readUTF8(buf);
                // not reader or illegal tag type
                assertTag(tag);
                let childContext;
                if (knowingType) {
                    const valueType = nbtPrototype[key];
                    // skip for undefined field or type not matched!
                    if (typeof valueType === "undefined" || (typeof valueType === "number" && valueType !== tag)) {
                        continue;
                    }
                    childContext = context.fork(valueType);
                }
                else {
                    childContext = context.fork(tag);
                }
                const shouldInspectChildType = !childContext.schema;
                // log(`[read] ${shouldInspectChildType ? 'inspecting' : ''} -> ${key}: ${JSON.stringify(childContext.schema)} ${TagType.getName(childContext.tagType)} ${TagType.getName(tag)}`);
                object[key] = reader.read(buf, childContext);
                // log(`[read] ${shouldInspectChildType ? 'inspecting' : ''} <- ${key}: ${JSON.stringify(childContext.schema)} ${TagType.getName(childContext.tagType)} ${TagType.getName(tag)} ${JSON.stringify(object[key])}`);
                if (shouldInspectChildType) {
                    nbtPrototype[key] = childContext.inspect || childContext.tagType;
                }
            }
            if (!knowingType) {
                context.inspect = nbtPrototype;
            }
            return object;
        },
        write(buf, object = {}, context) {
            assertCompoundSchema(context.schema);
            const schema = context.schema ? context.schema instanceof Function ? getPrototypeOf(context.schema) : context.schema : getPrototypeOf(object);
            for (const [key, value] of Object.entries(object)) {
                const valueType = schema[key];
                if (typeof valueType === "undefined") {
                    // skip for undefined property
                    continue;
                }
                const childContext = context.fork(valueType);
                const tagType = childContext.tagType;
                const writer = IO[tagType];
                assertTag(tagType);
                if (!childContext.schema && (tagType === TagType.Compound || tagType === TagType.List)) {
                    // skip for undefined property
                    continue;
                }
                // console.log(`Write ${key}: ${TagType.getName(tagType)} ${JSON.stringify(childContext.schema)} ${childContext.schema} ${childContext.schema instanceof Array}`)
                try {
                    buf.writeByte(tagType);
                    writeUTF8(buf, key);
                    writer.write(buf, value, childContext);
                }
                catch (e) {
                    if (e instanceof TypeError) {
                        throw new TypeError(`Required ${TagType.getName(tagType)} but found ${typeof value}`);
                    }
                }
            }
            buf.writeByte(TagType.End);
        },
    },
    {
        read(buf) {
            const arr = new Array(buf.readInt());
            for (let i = 0; i < arr.length; i++) {
                arr[i] = buf.readInt();
            }
            return arr;
        },
        write(buf, v = []) {
            buf.writeInt(v.length);
            for (let i = 0; i < v.length; i++) {
                buf.writeInt(v[i]);
            }
        },
    },
    {
        read(buf) {
            const len = buf.readInt();
            const arr = new Array(len);
            for (let i = 0; i < len; i++) {
                arr[i] = buf.readInt64();
            }
            return arr;
        },
        write(buf, v = []) {
            buf.writeInt(v.length);
            for (let i = 0; i < v.length; i++) {
                buf.writeInt64(v[i]);
            }
        },
    },
];
/**
 * Serialzie an nbt typed json object into NBT binary
 * @param object The json
 * @param compressed Should we compress it
 */
export async function serialize(object, option = {}) {
    const buff = writeRootTag(object, undefined, option.filename || "", Object.assign({}, IO, option.io));
    return normalizeBuffer(buff, option.compressed);
}
/**
 * Deserialize the nbt binary into json
 * @param fileData The nbt binary
 */
export async function deserialize(fileData, option = {}) {
    const doUnzip = normalizeCompress(fileData, option.compressed);
    const bb = ByteBuffer.wrap(doUnzip === "none"
        ? fileData
        : doUnzip === "gzip"
            ? await ungzip(fileData)
            : await inflate(fileData));
    return readRootTag(bb, Object.assign({}, IO, option.io), option.type);
}
/**
 * Serialzie an nbt typed json object into NBT binary
 * @param object The json
 */
export function serializeSync(object, option = {}) {
    const buff = writeRootTag(object, undefined, option.filename || "", Object.assign({}, IO, option.io));
    return normalizeBufferSync(buff, option.compressed);
}
/**
 * Deserialize the nbt binary into json
 * @param fileData The nbt binary
 * @param compressed Should we compress it
 */
export function deserializeSync(fileData, option = {}) {
    const doUnzip = normalizeCompress(fileData, option.compressed);
    const bb = ByteBuffer.wrap(doUnzip === "none"
        ? fileData
        : doUnzip === "gzip"
            ? gunzipSync(fileData)
            : inflateSync(fileData));
    return readRootTag(bb, Object.assign({}, IO, option.io), option.type);
}
function normalizeCompress(fileData, compressed) {
    let doUnzip;
    if (typeof compressed === "undefined") {
        const ft = fileType(fileData);
        doUnzip = ft !== undefined && ft.ext === "gz" ? "gzip" : "none";
    }
    else if (typeof compressed === "boolean" && compressed) {
        doUnzip = "gzip";
    }
    else {
        doUnzip = compressed;
    }
    return doUnzip;
}
function normalizeBuffer(buff, compressed) {
    if (!compressed) {
        return buff;
    }
    if (compressed === "deflate") {
        return deflate(buff);
    }
    return gzip(buff);
}
function normalizeBufferSync(buff, compressed) {
    if (!compressed) {
        return buff;
    }
    if (compressed === "deflate") {
        return deflateSync(buff);
    }
    return gzipSync(buff);
}
function readRootTag(buffer, io, type) {
    const rootType = buffer.readByte();
    if (rootType === TagType.End) {
        throw new Error("NBTEnd");
    }
    if (rootType !== TagType.Compound) {
        throw new Error("Root tag must be a named compound tag. " + rootType);
    }
    const name = readUTF8(buffer); // I think this is the nameProperty of the file...
    const context = new ReadContext(type, TagType.Compound);
    const value = io[TagType.Compound].read(buffer, context);
    return value;
}
function writeRootTag(value, type, filename, io) {
    const buffer = new ByteBuffer();
    buffer.writeByte(TagType.Compound);
    writeUTF8(buffer, filename || "");
    const context = new WriteContext(type, 10);
    io[TagType.Compound].write(buffer, value, context);
    return buffer.flip().buffer.slice(0, buffer.limit);
}
function assertListSchema(v) {
    if (!(v instanceof Array)) {
        throw new Error("IllegalState");
    }
}
function assertCompoundSchema(v) {
    if (v instanceof Array) {
        throw new Error("IllegalState");
    }
}
function assertTag(v) {
    if (!isTagType(v)) {
        throw new Error("Unknown type " + v);
    }
}
export class ReadContext {
    constructor(schema, tagType) {
        this.schema = schema;
        this.tagType = tagType;
    }
    fork(schemaOrTagType) {
        if (typeof schemaOrTagType === "number") {
            return new ReadContext(undefined, schemaOrTagType);
        }
        return new ReadContext(schemaOrTagType, typeof schemaOrTagType === "number" ? schemaOrTagType : schemaOrTagType instanceof Array ? TagType.List : TagType.Compound);
    }
}
export class WriteContext {
    constructor(schema, tagType) {
        this.schema = schema;
        this.tagType = tagType;
    }
    fork(schemaOrTagType) {
        if (schemaOrTagType === TagType.Compound) {
            throw new Error("IllegalState");
        }
        return new WriteContext(typeof schemaOrTagType === "number" ? undefined : schemaOrTagType, typeof schemaOrTagType === "number" ? schemaOrTagType : schemaOrTagType instanceof Array ? TagType.List : TagType.Compound);
    }
}
