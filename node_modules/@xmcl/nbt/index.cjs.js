'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

function _interopDefault (ex) { return (ex && (typeof ex === 'object') && 'default' in ex) ? ex['default'] : ex; }

var ByteBuffer = _interopDefault(require('bytebuffer'));
var fileType = _interopDefault(require('file-type'));
var zlib = require('./zlib');

function writeUTF8(out, str) {
    const strlen = str.length;
    let utflen = 0;
    let c;
    let count = 0;
    /* use charAt instead of copying String to char array */
    for (let idx = 0; idx < strlen; idx++) {
        c = str.charCodeAt(idx);
        if ((c >= 0x0001) && (c <= 0x007F)) {
            utflen++;
        }
        else if (c > 0x07FF) {
            utflen += 3;
        }
        else {
            utflen += 2;
        }
    }
    if (utflen > 65535) {
        throw new Error("encoded string too long: " + utflen + " bytes");
    }
    const bytearr = new Uint8Array(utflen + 2);
    bytearr[count++] = ((utflen >>> 8) & 0xFF);
    bytearr[count++] = ((utflen >>> 0) & 0xFF);
    let i = 0;
    for (i = 0; i < strlen; i++) {
        c = str.charCodeAt(i);
        if (!((c >= 0x0001) && (c <= 0x007F))) {
            break;
        }
        bytearr[count++] = c;
    }
    for (; i < strlen; i++) {
        c = str.charCodeAt(i);
        if ((c >= 0x0001) && (c <= 0x007F)) {
            bytearr[count++] = c;
        }
        else if (c > 0x07FF) {
            bytearr[count++] = (0xE0 | ((c >> 12) & 0x0F));
            bytearr[count++] = (0x80 | ((c >> 6) & 0x3F));
            bytearr[count++] = (0x80 | ((c >> 0) & 0x3F));
        }
        else {
            bytearr[count++] = (0xC0 | ((c >> 6) & 0x1F));
            bytearr[count++] = (0x80 | ((c >> 0) & 0x3F));
        }
    }
    out.append(bytearr);
    // out.write(bytearr, 0, utflen + 2);
    return utflen + 2;
}
function readUTF8(buff) {
    const utflen = buff.readUint16();
    const bytearr = new Array(utflen);
    const chararr = new Array(utflen);
    let c, char2, char3;
    let count = 0;
    let chararrCount = 0;
    for (let i = 0; i < utflen; i++) {
        bytearr[i] = (buff.readByte());
    }
    while (count < utflen) {
        c = bytearr[count] & 0xff;
        if (c > 127) {
            break;
        }
        count++;
        chararr[chararrCount++] = c;
    }
    while (count < utflen) {
        c = bytearr[count] & 0xff;
        switch (c >> 4) {
            case 0:
            case 1:
            case 2:
            case 3:
            case 4:
            case 5:
            case 6:
            case 7:
                /* 0xxxxxxx*/
                count++;
                chararr[chararrCount++] = c;
                break;
            case 12:
            case 13:
                /* 110x xxxx   10xx xxxx*/
                count += 2;
                if (count > utflen) {
                    throw new Error("malformed input: partial character at end");
                }
                char2 = bytearr[count - 1];
                if ((char2 & 0xC0) !== 0x80) {
                    throw new Error("malformed input around byte " + count);
                }
                chararr[chararrCount++] = (((c & 0x1F) << 6) |
                    (char2 & 0x3F));
                break;
            case 14:
                /* 1110 xxxx  10xx xxxx  10xx xxxx */
                count += 3;
                if (count > utflen) {
                    throw new Error("malformed input: partial character at end");
                }
                char2 = bytearr[count - 2];
                char3 = bytearr[count - 1];
                if (((char2 & 0xC0) !== 0x80) || ((char3 & 0xC0) !== 0x80)) {
                    throw new Error("malformed input around byte " + (count - 1));
                }
                chararr[chararrCount++] = (((c & 0x0F) << 12) |
                    ((char2 & 0x3F) << 6) |
                    ((char3 & 0x3F) << 0));
                break;
            default:
                /* 10xx xxxx,  1111 xxxx */
                throw new Error("malformed input around byte " + count);
        }
    }
    // The number of chars produced may be less than utflen
    return chararr.map((i) => String.fromCharCode(i)).join("");
}

/**
 * The nbt module provides nbt {@link serialize} and {@link deserialize} functions.
 *
 * @packageDocumentation
 */
const NBTPrototype = Symbol("NBTPrototype");
const NBTConstructor = Symbol("NBTConstructor");
/**
 * Annotate the type of a field
 */
function TagType(type) {
    return (targetClass, key) => {
        let nbtPrototype = getPrototypeOf(targetClass.constructor);
        nbtPrototype[key] = type;
    };
}
/**
 * Construct the object from schema or constructor.
 *
 * - If pass-in value type is a schema object, it create a prototype with constructor constructing the object with this schema as NBTPrototype.
 * - If pass-in value is a constructor, it will try to take the NBTPrototype on the constructor to create object.
 */
function constructObject(valueType) {
    if (!valueType) {
        return {};
    }
    const prot = typeof valueType === "object" ? createPrototypeFrom(valueType) : getPrototypeOf(valueType);
    return prot[NBTConstructor]();
}
function createPrototypeFrom(schema, constructor) {
    const proto = {
        ...schema,
    };
    Object.defineProperty(proto, NBTConstructor, {
        value: () => {
            let object;
            if (constructor) {
                try {
                    object = new constructor();
                }
                catch (_a) {
                    object = {};
                    Object.setPrototypeOf(object, constructor.prototype);
                }
            }
            else {
                object = {};
            }
            Object.defineProperty(object, NBTPrototype, { value: proto });
            return object;
        },
    });
    return proto;
}
/**
 * Get NBT schema for this object or a class.
 *
 * If the param is a object, any modifications on this prototype will only affact this object.
 *
 * If the param is a class, any modifications on this prototype will affact all object under this class
 *
 * @param object The object or class
 */
function getPrototypeOf(object) {
    const targetObject = typeof object === "function" ? object.prototype : object;
    let nbtPrototype;
    if (targetObject.hasOwnProperty(NBTPrototype)) {
        nbtPrototype = targetObject[NBTPrototype];
    }
    else {
        nbtPrototype = createPrototypeFrom({}, typeof object === "function" ? object : undefined);
    }
    // link prototype to parent's nbt prototype
    // we need to do this every time since the prototype chain might change
    const parentClass = Object.getPrototypeOf(targetObject);
    if (parentClass && parentClass !== Object.getPrototypeOf({})) {
        const parentNBTPrototype = getPrototypeOf(parentClass);
        const existedParentNBTPrototype = Object.getPrototypeOf(nbtPrototype);
        if (existedParentNBTPrototype !== parentNBTPrototype) {
            Object.setPrototypeOf(nbtPrototype, parentNBTPrototype);
        }
    }
    return new Proxy(nbtPrototype, {
        set(target, key, value) {
            if (!object.hasOwnProperty(NBTPrototype)) {
                setPrototypeOf(object, target);
            }
            if (typeof key === "string") {
                if (typeof value === "number" && !isTagType(value)) {
                    return false;
                }
                target[key] = value;
                return true;
            }
            return false;
        },
    });
}
/**
 * Set and change the NBT prototype of this object or class
 * @param object A object or a class function
 * @param nbtPrototype The nbt prototype
 */
function setPrototypeOf(object, nbtPrototype) {
    const target = typeof object === "function" ? object.prototype : object;
    Object.defineProperty(target, NBTPrototype, { value: nbtPrototype });
}
function isTagType(n) {
    return n >= 0 && n <= 12;
}
(function (TagType) {
    TagType.End = 0;
    TagType.Byte = 1;
    TagType.Short = 2;
    TagType.Int = 3;
    TagType.Long = 4;
    TagType.Float = 5;
    TagType.Double = 6;
    TagType.ByteArray = 7;
    TagType.String = 8;
    TagType.List = 9;
    TagType.Compound = 10;
    TagType.IntArray = 11;
    TagType.LongArray = 12;
    function getName(tagType) {
        return [
            "End",
            "Byte",
            "Short",
            "Int",
            "Long",
            "Float",
            "Double",
            "ByteArray",
            "String",
            "List",
            "Compound",
            "IntArray",
            "LongArray",
        ][tagType];
    }
    TagType.getName = getName;
})(TagType || (TagType = {}));
const IO = [
    { read: (buf) => undefined, write(buf, v) { } },
    { read: (buf) => buf.readByte(), write(buf, v = 0) { buf.writeByte(v); } },
    { read: (buf) => buf.readShort(), write(buf, v = 0) { buf.writeShort(v); } },
    { read: (buf) => buf.readInt(), write(buf, v = 0) { buf.writeInt(v); } },
    { read: (buf) => buf.readInt64(), write(buf, v = 0) { buf.writeInt64(v); } },
    { read: (buf) => buf.readFloat(), write(buf, v = 0) { buf.writeFloat(v); } },
    { read: (buf) => buf.readDouble(), write(buf, v = 0) { buf.writeDouble(v); } },
    {
        read(buf) {
            const arr = new Array(buf.readInt());
            for (let i = 0; i < arr.length; i++) {
                arr[i] = buf.readByte();
            }
            return arr;
        },
        write(buf, arr = []) {
            buf.writeInt(arr.length);
            for (let i = 0; i < arr.length; i++) {
                buf.writeByte(arr[i]);
            }
        },
    },
    { read: (buf) => readUTF8(buf), write: (buf, v = "") => writeUTF8(buf, v) },
    {
        read(buf, context) {
            const listType = buf.readByte();
            assertTag(listType);
            const len = buf.readInt();
            const list = new Array(len);
            if (context.schema) {
                assertListSchema(context.schema);
            }
            if (!!context.schema && typeof context.schema === "number" && listType !== context.schema) {
                // ignore the value if we know the type mismatched
                return list;
            }
            const childContext = context.fork(context.schema ? context.schema[0] : listType);
            const shouldInspectChildType = !childContext.schema;
            for (let i = 0; i < len; i++) {
                // console.log(`[read] ${shouldInspectChildType ? 'inspecting' : ''} -> [${i}]: ${JSON.stringify(nextContext.valueType)} ${TagType.getName(listType)}`);
                list[i] = IO[listType].read(buf, childContext);
                // console.log(`[read] ${shouldInspectChildType ? 'inspecting' : ''} <- [${i}]: ${JSON.stringify(nextContext.valueType)} ${TagType.getName(listType)} ${JSON.stringify(list[i])}`);
            }
            if (shouldInspectChildType) {
                context.inspect = childContext.inspect || [childContext.tagType];
            }
            return list;
        },
        write(buf, value = [], context) {
            assertListSchema(context.schema);
            const valueType = context.schema[0];
            const childContext = context.fork(valueType);
            const tagType = childContext.tagType;
            const writer = IO[tagType];
            assertTag(tagType);
            if ((tagType === TagType.Compound || tagType === TagType.List) && !childContext.schema) {
                // skip for undefined property
                return;
            }
            try {
                buf.writeByte(tagType);
                buf.writeInt(value.length);
                for (const v of value) {
                    writer.write(buf, v, childContext);
                }
            }
            catch (e) {
                if (e instanceof TypeError) {
                    throw new TypeError(`Require ${TagType.getName(tagType)} but found ${typeof value}`);
                }
            }
        },
    },
    {
        read(buf, context) {
            assertCompoundSchema(context.schema);
            const object = constructObject(context.schema); // create from constructor
            const nbtPrototype = getPrototypeOf(object);
            const knowingType = !!context.schema;
            for (let tag = 0; (tag = buf.readByte()) !== TagType.End;) {
                const reader = IO[tag];
                const key = readUTF8(buf);
                // not reader or illegal tag type
                assertTag(tag);
                let childContext;
                if (knowingType) {
                    const valueType = nbtPrototype[key];
                    // skip for undefined field or type not matched!
                    if (typeof valueType === "undefined" || (typeof valueType === "number" && valueType !== tag)) {
                        continue;
                    }
                    childContext = context.fork(valueType);
                }
                else {
                    childContext = context.fork(tag);
                }
                const shouldInspectChildType = !childContext.schema;
                // log(`[read] ${shouldInspectChildType ? 'inspecting' : ''} -> ${key}: ${JSON.stringify(childContext.schema)} ${TagType.getName(childContext.tagType)} ${TagType.getName(tag)}`);
                object[key] = reader.read(buf, childContext);
                // log(`[read] ${shouldInspectChildType ? 'inspecting' : ''} <- ${key}: ${JSON.stringify(childContext.schema)} ${TagType.getName(childContext.tagType)} ${TagType.getName(tag)} ${JSON.stringify(object[key])}`);
                if (shouldInspectChildType) {
                    nbtPrototype[key] = childContext.inspect || childContext.tagType;
                }
            }
            if (!knowingType) {
                context.inspect = nbtPrototype;
            }
            return object;
        },
        write(buf, object = {}, context) {
            assertCompoundSchema(context.schema);
            const schema = context.schema ? context.schema instanceof Function ? getPrototypeOf(context.schema) : context.schema : getPrototypeOf(object);
            for (const [key, value] of Object.entries(object)) {
                const valueType = schema[key];
                if (typeof valueType === "undefined") {
                    // skip for undefined property
                    continue;
                }
                const childContext = context.fork(valueType);
                const tagType = childContext.tagType;
                const writer = IO[tagType];
                assertTag(tagType);
                if (!childContext.schema && (tagType === TagType.Compound || tagType === TagType.List)) {
                    // skip for undefined property
                    continue;
                }
                // console.log(`Write ${key}: ${TagType.getName(tagType)} ${JSON.stringify(childContext.schema)} ${childContext.schema} ${childContext.schema instanceof Array}`)
                try {
                    buf.writeByte(tagType);
                    writeUTF8(buf, key);
                    writer.write(buf, value, childContext);
                }
                catch (e) {
                    if (e instanceof TypeError) {
                        throw new TypeError(`Required ${TagType.getName(tagType)} but found ${typeof value}`);
                    }
                }
            }
            buf.writeByte(TagType.End);
        },
    },
    {
        read(buf) {
            const arr = new Array(buf.readInt());
            for (let i = 0; i < arr.length; i++) {
                arr[i] = buf.readInt();
            }
            return arr;
        },
        write(buf, v = []) {
            buf.writeInt(v.length);
            for (let i = 0; i < v.length; i++) {
                buf.writeInt(v[i]);
            }
        },
    },
    {
        read(buf) {
            const len = buf.readInt();
            const arr = new Array(len);
            for (let i = 0; i < len; i++) {
                arr[i] = buf.readInt64();
            }
            return arr;
        },
        write(buf, v = []) {
            buf.writeInt(v.length);
            for (let i = 0; i < v.length; i++) {
                buf.writeInt64(v[i]);
            }
        },
    },
];
/**
 * Serialzie an nbt typed json object into NBT binary
 * @param object The json
 * @param compressed Should we compress it
 */
async function serialize(object, option = {}) {
    const buff = writeRootTag(object, undefined, option.filename || "", Object.assign({}, IO, option.io));
    return normalizeBuffer(buff, option.compressed);
}
/**
 * Deserialize the nbt binary into json
 * @param fileData The nbt binary
 */
async function deserialize(fileData, option = {}) {
    const doUnzip = normalizeCompress(fileData, option.compressed);
    const bb = ByteBuffer.wrap(doUnzip === "none"
        ? fileData
        : doUnzip === "gzip"
            ? await zlib.ungzip(fileData)
            : await zlib.inflate(fileData));
    return readRootTag(bb, Object.assign({}, IO, option.io), option.type);
}
/**
 * Serialzie an nbt typed json object into NBT binary
 * @param object The json
 */
function serializeSync(object, option = {}) {
    const buff = writeRootTag(object, undefined, option.filename || "", Object.assign({}, IO, option.io));
    return normalizeBufferSync(buff, option.compressed);
}
/**
 * Deserialize the nbt binary into json
 * @param fileData The nbt binary
 * @param compressed Should we compress it
 */
function deserializeSync(fileData, option = {}) {
    const doUnzip = normalizeCompress(fileData, option.compressed);
    const bb = ByteBuffer.wrap(doUnzip === "none"
        ? fileData
        : doUnzip === "gzip"
            ? zlib.gunzipSync(fileData)
            : zlib.inflateSync(fileData));
    return readRootTag(bb, Object.assign({}, IO, option.io), option.type);
}
function normalizeCompress(fileData, compressed) {
    let doUnzip;
    if (typeof compressed === "undefined") {
        const ft = fileType(fileData);
        doUnzip = ft !== undefined && ft.ext === "gz" ? "gzip" : "none";
    }
    else if (typeof compressed === "boolean" && compressed) {
        doUnzip = "gzip";
    }
    else {
        doUnzip = compressed;
    }
    return doUnzip;
}
function normalizeBuffer(buff, compressed) {
    if (!compressed) {
        return buff;
    }
    if (compressed === "deflate") {
        return zlib.deflate(buff);
    }
    return zlib.gzip(buff);
}
function normalizeBufferSync(buff, compressed) {
    if (!compressed) {
        return buff;
    }
    if (compressed === "deflate") {
        return zlib.deflateSync(buff);
    }
    return zlib.gzipSync(buff);
}
function readRootTag(buffer, io, type) {
    const rootType = buffer.readByte();
    if (rootType === TagType.End) {
        throw new Error("NBTEnd");
    }
    if (rootType !== TagType.Compound) {
        throw new Error("Root tag must be a named compound tag. " + rootType);
    }
    const name = readUTF8(buffer); // I think this is the nameProperty of the file...
    const context = new ReadContext(type, TagType.Compound);
    const value = io[TagType.Compound].read(buffer, context);
    return value;
}
function writeRootTag(value, type, filename, io) {
    const buffer = new ByteBuffer();
    buffer.writeByte(TagType.Compound);
    writeUTF8(buffer, filename || "");
    const context = new WriteContext(type, 10);
    io[TagType.Compound].write(buffer, value, context);
    return buffer.flip().buffer.slice(0, buffer.limit);
}
function assertListSchema(v) {
    if (!(v instanceof Array)) {
        throw new Error("IllegalState");
    }
}
function assertCompoundSchema(v) {
    if (v instanceof Array) {
        throw new Error("IllegalState");
    }
}
function assertTag(v) {
    if (!isTagType(v)) {
        throw new Error("Unknown type " + v);
    }
}
class ReadContext {
    constructor(schema, tagType) {
        this.schema = schema;
        this.tagType = tagType;
    }
    fork(schemaOrTagType) {
        if (typeof schemaOrTagType === "number") {
            return new ReadContext(undefined, schemaOrTagType);
        }
        return new ReadContext(schemaOrTagType, typeof schemaOrTagType === "number" ? schemaOrTagType : schemaOrTagType instanceof Array ? TagType.List : TagType.Compound);
    }
}
class WriteContext {
    constructor(schema, tagType) {
        this.schema = schema;
        this.tagType = tagType;
    }
    fork(schemaOrTagType) {
        if (schemaOrTagType === TagType.Compound) {
            throw new Error("IllegalState");
        }
        return new WriteContext(typeof schemaOrTagType === "number" ? undefined : schemaOrTagType, typeof schemaOrTagType === "number" ? schemaOrTagType : schemaOrTagType instanceof Array ? TagType.List : TagType.Compound);
    }
}

exports.NBTConstructor = NBTConstructor;
exports.NBTPrototype = NBTPrototype;
exports.ReadContext = ReadContext;
exports.TagType = TagType;
exports.WriteContext = WriteContext;
exports.deserialize = deserialize;
exports.deserializeSync = deserializeSync;
exports.getPrototypeOf = getPrototypeOf;
exports.serialize = serialize;
exports.serializeSync = serializeSync;
exports.setPrototypeOf = setPrototypeOf;
